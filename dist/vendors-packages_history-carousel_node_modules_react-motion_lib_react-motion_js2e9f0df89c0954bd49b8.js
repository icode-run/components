(self["webpackChunkicode_run"] = self["webpackChunkicode_run"] || []).push([["vendors-packages_history-carousel_node_modules_react-motion_lib_react-motion_js"],{

/***/ 36625:
/***/ (function(module) {

// Generated by CoffeeScript 1.7.1
(function(){var getNanoSeconds,hrtime,loadTime;if(typeof performance!=="undefined"&&performance!==null&&performance.now){module.exports=function(){return performance.now();};}else if(typeof process!=="undefined"&&process!==null&&process.hrtime){module.exports=function(){return(getNanoSeconds()-loadTime)/1e6;};hrtime=process.hrtime;getNanoSeconds=function getNanoSeconds(){var hr;hr=hrtime();return hr[0]*1e9+hr[1];};loadTime=getNanoSeconds();}else if(Date.now){module.exports=function(){return Date.now()-loadTime;};loadTime=Date.now();}else{module.exports=function(){return new Date().getTime()-loadTime;};loadTime=new Date().getTime();}}).call(this);

/***/ }),

/***/ 15628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ReactPropTypesSecret=__webpack_require__(41840);function emptyFunction(){}function emptyFunctionWithReset(){}emptyFunctionWithReset.resetWarningCache=emptyFunction;module.exports=function(){function shim(props,propName,componentName,location,propFullName,secret){if(secret===ReactPropTypesSecret){// It is still safe when called from React.
return;}var err=new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. '+'Use PropTypes.checkPropTypes() to call them. '+'Read more at http://fb.me/use-check-prop-types');err.name='Invariant Violation';throw err;};shim.isRequired=shim;function getShim(){return shim;};// Important!
// Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
var ReactPropTypes={array:shim,bigint:shim,bool:shim,func:shim,number:shim,object:shim,string:shim,symbol:shim,any:shim,arrayOf:getShim,element:shim,elementType:shim,instanceOf:getShim,node:shim,objectOf:getShim,oneOf:getShim,oneOfType:getShim,shape:getShim,exact:getShim,checkPropTypes:emptyFunctionWithReset,resetWarningCache:emptyFunction};ReactPropTypes.PropTypes=ReactPropTypes;return ReactPropTypes;};

/***/ }),

/***/ 45931:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */if(false){ var throwOnDirectAccess, ReactIs; }else{// By explicitly using `prop-types` you are opting into new production behavior.
// http://fb.me/prop-types-in-prod
module.exports=__webpack_require__(15628)();}

/***/ }),

/***/ 41840:
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ReactPropTypesSecret='SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';module.exports=ReactPropTypesSecret;

/***/ }),

/***/ 32805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var now=__webpack_require__(40218),root=typeof window==='undefined'?__webpack_require__.g:window,vendors=['moz','webkit'],suffix='AnimationFrame',raf=root['request'+suffix],caf=root['cancel'+suffix]||root['cancelRequest'+suffix];for(var i=0;!raf&&i<vendors.length;i++){raf=root[vendors[i]+'Request'+suffix];caf=root[vendors[i]+'Cancel'+suffix]||root[vendors[i]+'CancelRequest'+suffix];}// Some versions of FF have rAF but not cAF
if(!raf||!caf){var last=0,id=0,queue=[],frameDuration=1000/60;raf=function raf(callback){if(queue.length===0){var _now=now(),next=Math.max(0,frameDuration-(_now-last));last=next+_now;setTimeout(function(){var cp=queue.slice(0);// Clear queue here to prevent
// callbacks from appending listeners
// to the current frame's queue
queue.length=0;for(var i=0;i<cp.length;i++){if(!cp[i].cancelled){try{cp[i].callback(last);}catch(e){setTimeout(function(){throw e;},0);}}}},Math.round(next));}queue.push({handle:++id,callback:callback,cancelled:false});return id;};caf=function caf(handle){for(var i=0;i<queue.length;i++){if(queue[i].handle===handle){queue[i].cancelled=true;}}};}module.exports=function(fn){// Wrap in a new function to prevent
// `cancel` potentially being assigned
// to the native rAF function
return raf.call(root,fn);};module.exports.cancel=function(){caf.apply(root,arguments);};module.exports.polyfill=function(object){if(!object){object=root;}object.requestAnimationFrame=raf;object.cancelAnimationFrame=caf;};

/***/ }),

/***/ 40218:
/***/ (function(module) {

// Generated by CoffeeScript 1.12.2
(function(){var getNanoSeconds,hrtime,loadTime,moduleLoadTime,nodeLoadTime,upTime;if(typeof performance!=="undefined"&&performance!==null&&performance.now){module.exports=function(){return performance.now();};}else if(typeof process!=="undefined"&&process!==null&&process.hrtime){module.exports=function(){return(getNanoSeconds()-nodeLoadTime)/1e6;};hrtime=process.hrtime;getNanoSeconds=function getNanoSeconds(){var hr;hr=hrtime();return hr[0]*1e9+hr[1];};moduleLoadTime=getNanoSeconds();upTime=process.uptime()*1e9;nodeLoadTime=moduleLoadTime-upTime;}else if(Date.now){module.exports=function(){return Date.now()-loadTime;};loadTime=Date.now();}else{module.exports=function(){return new Date().getTime()-loadTime;};loadTime=new Date().getTime();}}).call(this);

/***/ }),

/***/ 19143:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}exports.__esModule=true;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{'default':obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function');}}function _inherits(subClass,superClass){if(typeof superClass!=='function'&&superClass!==null){throw new TypeError('Super expression must either be null or a function, not '+_typeof(superClass));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var _mapToZero=__webpack_require__(34419);var _mapToZero2=_interopRequireDefault(_mapToZero);var _stripStyle=__webpack_require__(93374);var _stripStyle2=_interopRequireDefault(_stripStyle);var _stepper3=__webpack_require__(98299);var _stepper4=_interopRequireDefault(_stepper3);var _performanceNow=__webpack_require__(36625);var _performanceNow2=_interopRequireDefault(_performanceNow);var _raf=__webpack_require__(32805);var _raf2=_interopRequireDefault(_raf);var _shouldStopAnimation=__webpack_require__(18412);var _shouldStopAnimation2=_interopRequireDefault(_shouldStopAnimation);var _react=__webpack_require__(46153);var _react2=_interopRequireDefault(_react);var _propTypes=__webpack_require__(45931);var _propTypes2=_interopRequireDefault(_propTypes);var msPerFrame=1000/60;var Motion=function(_React$Component){_inherits(Motion,_React$Component);_createClass(Motion,null,[{key:'propTypes',value:{// TOOD: warn against putting a config in here
defaultStyle:_propTypes2['default'].objectOf(_propTypes2['default'].number),style:_propTypes2['default'].objectOf(_propTypes2['default'].oneOfType([_propTypes2['default'].number,_propTypes2['default'].object])).isRequired,children:_propTypes2['default'].func.isRequired,onRest:_propTypes2['default'].func},enumerable:true}]);function Motion(props){var _this=this;_classCallCheck(this,Motion);_React$Component.call(this,props);this.wasAnimating=false;this.animationID=null;this.prevTime=0;this.accumulatedTime=0;this.unreadPropStyle=null;this.clearUnreadPropStyle=function(destStyle){var dirty=false;var _state=_this.state;var currentStyle=_state.currentStyle;var currentVelocity=_state.currentVelocity;var lastIdealStyle=_state.lastIdealStyle;var lastIdealVelocity=_state.lastIdealVelocity;for(var key in destStyle){if(!Object.prototype.hasOwnProperty.call(destStyle,key)){continue;}var styleValue=destStyle[key];if(typeof styleValue==='number'){if(!dirty){dirty=true;currentStyle=_extends({},currentStyle);currentVelocity=_extends({},currentVelocity);lastIdealStyle=_extends({},lastIdealStyle);lastIdealVelocity=_extends({},lastIdealVelocity);}currentStyle[key]=styleValue;currentVelocity[key]=0;lastIdealStyle[key]=styleValue;lastIdealVelocity[key]=0;}}if(dirty){_this.setState({currentStyle:currentStyle,currentVelocity:currentVelocity,lastIdealStyle:lastIdealStyle,lastIdealVelocity:lastIdealVelocity});}};this.startAnimationIfNecessary=function(){// TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
// call cb? No, otherwise accidental parent rerender causes cb trigger
_this.animationID=_raf2['default'](function(timestamp){// check if we need to animate in the first place
var propsStyle=_this.props.style;if(_shouldStopAnimation2['default'](_this.state.currentStyle,propsStyle,_this.state.currentVelocity)){if(_this.wasAnimating&&_this.props.onRest){_this.props.onRest();}// no need to cancel animationID here; shouldn't have any in flight
_this.animationID=null;_this.wasAnimating=false;_this.accumulatedTime=0;return;}_this.wasAnimating=true;var currentTime=timestamp||_performanceNow2['default']();var timeDelta=currentTime-_this.prevTime;_this.prevTime=currentTime;_this.accumulatedTime=_this.accumulatedTime+timeDelta;// more than 10 frames? prolly switched browser tab. Restart
if(_this.accumulatedTime>msPerFrame*10){_this.accumulatedTime=0;}if(_this.accumulatedTime===0){// no need to cancel animationID here; shouldn't have any in flight
_this.animationID=null;_this.startAnimationIfNecessary();return;}var currentFrameCompletion=(_this.accumulatedTime-Math.floor(_this.accumulatedTime/msPerFrame)*msPerFrame)/msPerFrame;var framesToCatchUp=Math.floor(_this.accumulatedTime/msPerFrame);var newLastIdealStyle={};var newLastIdealVelocity={};var newCurrentStyle={};var newCurrentVelocity={};for(var key in propsStyle){if(!Object.prototype.hasOwnProperty.call(propsStyle,key)){continue;}var styleValue=propsStyle[key];if(typeof styleValue==='number'){newCurrentStyle[key]=styleValue;newCurrentVelocity[key]=0;newLastIdealStyle[key]=styleValue;newLastIdealVelocity[key]=0;}else{var newLastIdealStyleValue=_this.state.lastIdealStyle[key];var newLastIdealVelocityValue=_this.state.lastIdealVelocity[key];for(var i=0;i<framesToCatchUp;i++){var _stepper=_stepper4['default'](msPerFrame/1000,newLastIdealStyleValue,newLastIdealVelocityValue,styleValue.val,styleValue.stiffness,styleValue.damping,styleValue.precision);newLastIdealStyleValue=_stepper[0];newLastIdealVelocityValue=_stepper[1];}var _stepper2=_stepper4['default'](msPerFrame/1000,newLastIdealStyleValue,newLastIdealVelocityValue,styleValue.val,styleValue.stiffness,styleValue.damping,styleValue.precision);var nextIdealX=_stepper2[0];var nextIdealV=_stepper2[1];newCurrentStyle[key]=newLastIdealStyleValue+(nextIdealX-newLastIdealStyleValue)*currentFrameCompletion;newCurrentVelocity[key]=newLastIdealVelocityValue+(nextIdealV-newLastIdealVelocityValue)*currentFrameCompletion;newLastIdealStyle[key]=newLastIdealStyleValue;newLastIdealVelocity[key]=newLastIdealVelocityValue;}}_this.animationID=null;// the amount we're looped over above
_this.accumulatedTime-=framesToCatchUp*msPerFrame;_this.setState({currentStyle:newCurrentStyle,currentVelocity:newCurrentVelocity,lastIdealStyle:newLastIdealStyle,lastIdealVelocity:newLastIdealVelocity});_this.unreadPropStyle=null;_this.startAnimationIfNecessary();});};this.state=this.defaultState();}Motion.prototype.defaultState=function defaultState(){var _props=this.props;var defaultStyle=_props.defaultStyle;var style=_props.style;var currentStyle=defaultStyle||_stripStyle2['default'](style);var currentVelocity=_mapToZero2['default'](currentStyle);return{currentStyle:currentStyle,currentVelocity:currentVelocity,lastIdealStyle:currentStyle,lastIdealVelocity:currentVelocity};};// it's possible that currentStyle's value is stale: if props is immediately
// changed from 0 to 400 to spring(0) again, the async currentStyle is still
// at 0 (didn't have time to tick and interpolate even once). If we naively
// compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
// In reality currentStyle should be 400
Motion.prototype.componentDidMount=function componentDidMount(){this.prevTime=_performanceNow2['default']();this.startAnimationIfNecessary();};Motion.prototype.componentWillReceiveProps=function componentWillReceiveProps(props){if(this.unreadPropStyle!=null){// previous props haven't had the chance to be set yet; set them here
this.clearUnreadPropStyle(this.unreadPropStyle);}this.unreadPropStyle=props.style;if(this.animationID==null){this.prevTime=_performanceNow2['default']();this.startAnimationIfNecessary();}};Motion.prototype.componentWillUnmount=function componentWillUnmount(){if(this.animationID!=null){_raf2['default'].cancel(this.animationID);this.animationID=null;}};Motion.prototype.render=function render(){var renderedChildren=this.props.children(this.state.currentStyle);return renderedChildren&&_react2['default'].Children.only(renderedChildren);};return Motion;}(_react2['default'].Component);exports["default"]=Motion;module.exports=exports['default'];// after checking for unreadPropStyle != null, we manually go set the
// non-interpolating values (those that are a number, without a spring
// config)

/***/ }),

/***/ 40164:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}exports.__esModule=true;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{'default':obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function');}}function _inherits(subClass,superClass){if(typeof superClass!=='function'&&superClass!==null){throw new TypeError('Super expression must either be null or a function, not '+_typeof(superClass));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var _mapToZero=__webpack_require__(34419);var _mapToZero2=_interopRequireDefault(_mapToZero);var _stripStyle=__webpack_require__(93374);var _stripStyle2=_interopRequireDefault(_stripStyle);var _stepper3=__webpack_require__(98299);var _stepper4=_interopRequireDefault(_stepper3);var _performanceNow=__webpack_require__(36625);var _performanceNow2=_interopRequireDefault(_performanceNow);var _raf=__webpack_require__(32805);var _raf2=_interopRequireDefault(_raf);var _shouldStopAnimation=__webpack_require__(18412);var _shouldStopAnimation2=_interopRequireDefault(_shouldStopAnimation);var _react=__webpack_require__(46153);var _react2=_interopRequireDefault(_react);var _propTypes=__webpack_require__(45931);var _propTypes2=_interopRequireDefault(_propTypes);var msPerFrame=1000/60;function shouldStopAnimationAll(currentStyles,styles,currentVelocities){for(var i=0;i<currentStyles.length;i++){if(!_shouldStopAnimation2['default'](currentStyles[i],styles[i],currentVelocities[i])){return false;}}return true;}var StaggeredMotion=function(_React$Component){_inherits(StaggeredMotion,_React$Component);_createClass(StaggeredMotion,null,[{key:'propTypes',value:{// TOOD: warn against putting a config in here
defaultStyles:_propTypes2['default'].arrayOf(_propTypes2['default'].objectOf(_propTypes2['default'].number)),styles:_propTypes2['default'].func.isRequired,children:_propTypes2['default'].func.isRequired},enumerable:true}]);function StaggeredMotion(props){var _this=this;_classCallCheck(this,StaggeredMotion);_React$Component.call(this,props);this.animationID=null;this.prevTime=0;this.accumulatedTime=0;this.unreadPropStyles=null;this.clearUnreadPropStyle=function(unreadPropStyles){var _state=_this.state;var currentStyles=_state.currentStyles;var currentVelocities=_state.currentVelocities;var lastIdealStyles=_state.lastIdealStyles;var lastIdealVelocities=_state.lastIdealVelocities;var someDirty=false;for(var i=0;i<unreadPropStyles.length;i++){var unreadPropStyle=unreadPropStyles[i];var dirty=false;for(var key in unreadPropStyle){if(!Object.prototype.hasOwnProperty.call(unreadPropStyle,key)){continue;}var styleValue=unreadPropStyle[key];if(typeof styleValue==='number'){if(!dirty){dirty=true;someDirty=true;currentStyles[i]=_extends({},currentStyles[i]);currentVelocities[i]=_extends({},currentVelocities[i]);lastIdealStyles[i]=_extends({},lastIdealStyles[i]);lastIdealVelocities[i]=_extends({},lastIdealVelocities[i]);}currentStyles[i][key]=styleValue;currentVelocities[i][key]=0;lastIdealStyles[i][key]=styleValue;lastIdealVelocities[i][key]=0;}}}if(someDirty){_this.setState({currentStyles:currentStyles,currentVelocities:currentVelocities,lastIdealStyles:lastIdealStyles,lastIdealVelocities:lastIdealVelocities});}};this.startAnimationIfNecessary=function(){// TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
// call cb? No, otherwise accidental parent rerender causes cb trigger
_this.animationID=_raf2['default'](function(timestamp){var destStyles=_this.props.styles(_this.state.lastIdealStyles);// check if we need to animate in the first place
if(shouldStopAnimationAll(_this.state.currentStyles,destStyles,_this.state.currentVelocities)){// no need to cancel animationID here; shouldn't have any in flight
_this.animationID=null;_this.accumulatedTime=0;return;}var currentTime=timestamp||_performanceNow2['default']();var timeDelta=currentTime-_this.prevTime;_this.prevTime=currentTime;_this.accumulatedTime=_this.accumulatedTime+timeDelta;// more than 10 frames? prolly switched browser tab. Restart
if(_this.accumulatedTime>msPerFrame*10){_this.accumulatedTime=0;}if(_this.accumulatedTime===0){// no need to cancel animationID here; shouldn't have any in flight
_this.animationID=null;_this.startAnimationIfNecessary();return;}var currentFrameCompletion=(_this.accumulatedTime-Math.floor(_this.accumulatedTime/msPerFrame)*msPerFrame)/msPerFrame;var framesToCatchUp=Math.floor(_this.accumulatedTime/msPerFrame);var newLastIdealStyles=[];var newLastIdealVelocities=[];var newCurrentStyles=[];var newCurrentVelocities=[];for(var i=0;i<destStyles.length;i++){var destStyle=destStyles[i];var newCurrentStyle={};var newCurrentVelocity={};var newLastIdealStyle={};var newLastIdealVelocity={};for(var key in destStyle){if(!Object.prototype.hasOwnProperty.call(destStyle,key)){continue;}var styleValue=destStyle[key];if(typeof styleValue==='number'){newCurrentStyle[key]=styleValue;newCurrentVelocity[key]=0;newLastIdealStyle[key]=styleValue;newLastIdealVelocity[key]=0;}else{var newLastIdealStyleValue=_this.state.lastIdealStyles[i][key];var newLastIdealVelocityValue=_this.state.lastIdealVelocities[i][key];for(var j=0;j<framesToCatchUp;j++){var _stepper=_stepper4['default'](msPerFrame/1000,newLastIdealStyleValue,newLastIdealVelocityValue,styleValue.val,styleValue.stiffness,styleValue.damping,styleValue.precision);newLastIdealStyleValue=_stepper[0];newLastIdealVelocityValue=_stepper[1];}var _stepper2=_stepper4['default'](msPerFrame/1000,newLastIdealStyleValue,newLastIdealVelocityValue,styleValue.val,styleValue.stiffness,styleValue.damping,styleValue.precision);var nextIdealX=_stepper2[0];var nextIdealV=_stepper2[1];newCurrentStyle[key]=newLastIdealStyleValue+(nextIdealX-newLastIdealStyleValue)*currentFrameCompletion;newCurrentVelocity[key]=newLastIdealVelocityValue+(nextIdealV-newLastIdealVelocityValue)*currentFrameCompletion;newLastIdealStyle[key]=newLastIdealStyleValue;newLastIdealVelocity[key]=newLastIdealVelocityValue;}}newCurrentStyles[i]=newCurrentStyle;newCurrentVelocities[i]=newCurrentVelocity;newLastIdealStyles[i]=newLastIdealStyle;newLastIdealVelocities[i]=newLastIdealVelocity;}_this.animationID=null;// the amount we're looped over above
_this.accumulatedTime-=framesToCatchUp*msPerFrame;_this.setState({currentStyles:newCurrentStyles,currentVelocities:newCurrentVelocities,lastIdealStyles:newLastIdealStyles,lastIdealVelocities:newLastIdealVelocities});_this.unreadPropStyles=null;_this.startAnimationIfNecessary();});};this.state=this.defaultState();}StaggeredMotion.prototype.defaultState=function defaultState(){var _props=this.props;var defaultStyles=_props.defaultStyles;var styles=_props.styles;var currentStyles=defaultStyles||styles().map(_stripStyle2['default']);var currentVelocities=currentStyles.map(function(currentStyle){return _mapToZero2['default'](currentStyle);});return{currentStyles:currentStyles,currentVelocities:currentVelocities,lastIdealStyles:currentStyles,lastIdealVelocities:currentVelocities};};StaggeredMotion.prototype.componentDidMount=function componentDidMount(){this.prevTime=_performanceNow2['default']();this.startAnimationIfNecessary();};StaggeredMotion.prototype.componentWillReceiveProps=function componentWillReceiveProps(props){if(this.unreadPropStyles!=null){// previous props haven't had the chance to be set yet; set them here
this.clearUnreadPropStyle(this.unreadPropStyles);}this.unreadPropStyles=props.styles(this.state.lastIdealStyles);if(this.animationID==null){this.prevTime=_performanceNow2['default']();this.startAnimationIfNecessary();}};StaggeredMotion.prototype.componentWillUnmount=function componentWillUnmount(){if(this.animationID!=null){_raf2['default'].cancel(this.animationID);this.animationID=null;}};StaggeredMotion.prototype.render=function render(){var renderedChildren=this.props.children(this.state.currentStyles);return renderedChildren&&_react2['default'].Children.only(renderedChildren);};return StaggeredMotion;}(_react2['default'].Component);exports["default"]=StaggeredMotion;module.exports=exports['default'];// it's possible that currentStyle's value is stale: if props is immediately
// changed from 0 to 400 to spring(0) again, the async currentStyle is still
// at 0 (didn't have time to tick and interpolate even once). If we naively
// compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
// In reality currentStyle should be 400
// after checking for unreadPropStyles != null, we manually go set the
// non-interpolating values (those that are a number, without a spring
// config)

/***/ }),

/***/ 96081:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}exports.__esModule=true;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{'default':obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function');}}function _inherits(subClass,superClass){if(typeof superClass!=='function'&&superClass!==null){throw new TypeError('Super expression must either be null or a function, not '+_typeof(superClass));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var _mapToZero=__webpack_require__(34419);var _mapToZero2=_interopRequireDefault(_mapToZero);var _stripStyle=__webpack_require__(93374);var _stripStyle2=_interopRequireDefault(_stripStyle);var _stepper3=__webpack_require__(98299);var _stepper4=_interopRequireDefault(_stepper3);var _mergeDiff=__webpack_require__(8940);var _mergeDiff2=_interopRequireDefault(_mergeDiff);var _performanceNow=__webpack_require__(36625);var _performanceNow2=_interopRequireDefault(_performanceNow);var _raf=__webpack_require__(32805);var _raf2=_interopRequireDefault(_raf);var _shouldStopAnimation=__webpack_require__(18412);var _shouldStopAnimation2=_interopRequireDefault(_shouldStopAnimation);var _react=__webpack_require__(46153);var _react2=_interopRequireDefault(_react);var _propTypes=__webpack_require__(45931);var _propTypes2=_interopRequireDefault(_propTypes);var msPerFrame=1000/60;// the children function & (potential) styles function asks as param an
// Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format
// {key: string, data?: any, style: PlainStyle}. However, the way we keep
// internal states doesn't contain such a data structure (check the state and
// TransitionMotionState). So when children function and others ask for such
// data we need to generate them on the fly by combining mergedPropsStyles and
// currentStyles/lastIdealStyles
function rehydrateStyles(mergedPropsStyles,unreadPropStyles,plainStyles){// Copy the value to a `const` so that Flow understands that the const won't
// change and will be non-nullable in the callback below.
var cUnreadPropStyles=unreadPropStyles;if(cUnreadPropStyles==null){return mergedPropsStyles.map(function(mergedPropsStyle,i){return{key:mergedPropsStyle.key,data:mergedPropsStyle.data,style:plainStyles[i]};});}return mergedPropsStyles.map(function(mergedPropsStyle,i){for(var j=0;j<cUnreadPropStyles.length;j++){if(cUnreadPropStyles[j].key===mergedPropsStyle.key){return{key:cUnreadPropStyles[j].key,data:cUnreadPropStyles[j].data,style:plainStyles[i]};}}return{key:mergedPropsStyle.key,data:mergedPropsStyle.data,style:plainStyles[i]};});}function shouldStopAnimationAll(currentStyles,destStyles,currentVelocities,mergedPropsStyles){if(mergedPropsStyles.length!==destStyles.length){return false;}for(var i=0;i<mergedPropsStyles.length;i++){if(mergedPropsStyles[i].key!==destStyles[i].key){return false;}}// we have the invariant that mergedPropsStyles and
// currentStyles/currentVelocities/last* are synced in terms of cells, see
// mergeAndSync comment for more info
for(var i=0;i<mergedPropsStyles.length;i++){if(!_shouldStopAnimation2['default'](currentStyles[i],destStyles[i].style,currentVelocities[i])){return false;}}return true;}// core key merging logic
// things to do: say previously merged style is {a, b}, dest style (prop) is {b,
// c}, previous current (interpolating) style is {a, b}
// **invariant**: current[i] corresponds to merged[i] in terms of key
// steps:
// turn merged style into {a?, b, c}
//    add c, value of c is destStyles.c
//    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}
// turn current (interpolating) style from {a, b} into {a?, b, c}
//    maybe remove a
//    certainly add c, value of c is willEnter(c)
// loop over merged and construct new current
// dest doesn't change, that's owner's
function mergeAndSync(willEnter,willLeave,didLeave,oldMergedPropsStyles,destStyles,oldCurrentStyles,oldCurrentVelocities,oldLastIdealStyles,oldLastIdealVelocities){var newMergedPropsStyles=_mergeDiff2['default'](oldMergedPropsStyles,destStyles,function(oldIndex,oldMergedPropsStyle){var leavingStyle=willLeave(oldMergedPropsStyle);if(leavingStyle==null){didLeave({key:oldMergedPropsStyle.key,data:oldMergedPropsStyle.data});return null;}if(_shouldStopAnimation2['default'](oldCurrentStyles[oldIndex],leavingStyle,oldCurrentVelocities[oldIndex])){didLeave({key:oldMergedPropsStyle.key,data:oldMergedPropsStyle.data});return null;}return{key:oldMergedPropsStyle.key,data:oldMergedPropsStyle.data,style:leavingStyle};});var newCurrentStyles=[];var newCurrentVelocities=[];var newLastIdealStyles=[];var newLastIdealVelocities=[];for(var i=0;i<newMergedPropsStyles.length;i++){var newMergedPropsStyleCell=newMergedPropsStyles[i];var foundOldIndex=null;for(var j=0;j<oldMergedPropsStyles.length;j++){if(oldMergedPropsStyles[j].key===newMergedPropsStyleCell.key){foundOldIndex=j;break;}}// TODO: key search code
if(foundOldIndex==null){var plainStyle=willEnter(newMergedPropsStyleCell);newCurrentStyles[i]=plainStyle;newLastIdealStyles[i]=plainStyle;var velocity=_mapToZero2['default'](newMergedPropsStyleCell.style);newCurrentVelocities[i]=velocity;newLastIdealVelocities[i]=velocity;}else{newCurrentStyles[i]=oldCurrentStyles[foundOldIndex];newLastIdealStyles[i]=oldLastIdealStyles[foundOldIndex];newCurrentVelocities[i]=oldCurrentVelocities[foundOldIndex];newLastIdealVelocities[i]=oldLastIdealVelocities[foundOldIndex];}}return[newMergedPropsStyles,newCurrentStyles,newCurrentVelocities,newLastIdealStyles,newLastIdealVelocities];}var TransitionMotion=function(_React$Component){_inherits(TransitionMotion,_React$Component);_createClass(TransitionMotion,null,[{key:'propTypes',value:{defaultStyles:_propTypes2['default'].arrayOf(_propTypes2['default'].shape({key:_propTypes2['default'].string.isRequired,data:_propTypes2['default'].any,style:_propTypes2['default'].objectOf(_propTypes2['default'].number).isRequired})),styles:_propTypes2['default'].oneOfType([_propTypes2['default'].func,_propTypes2['default'].arrayOf(_propTypes2['default'].shape({key:_propTypes2['default'].string.isRequired,data:_propTypes2['default'].any,style:_propTypes2['default'].objectOf(_propTypes2['default'].oneOfType([_propTypes2['default'].number,_propTypes2['default'].object])).isRequired}))]).isRequired,children:_propTypes2['default'].func.isRequired,willEnter:_propTypes2['default'].func,willLeave:_propTypes2['default'].func,didLeave:_propTypes2['default'].func},enumerable:true},{key:'defaultProps',value:{willEnter:function willEnter(styleThatEntered){return _stripStyle2['default'](styleThatEntered.style);},// recall: returning null makes the current unmounting TransitionStyle
// disappear immediately
willLeave:function willLeave(){return null;},didLeave:function didLeave(){}},enumerable:true}]);function TransitionMotion(props){var _this=this;_classCallCheck(this,TransitionMotion);_React$Component.call(this,props);this.unmounting=false;this.animationID=null;this.prevTime=0;this.accumulatedTime=0;this.unreadPropStyles=null;this.clearUnreadPropStyle=function(unreadPropStyles){var _mergeAndSync=mergeAndSync(_this.props.willEnter,_this.props.willLeave,_this.props.didLeave,_this.state.mergedPropsStyles,unreadPropStyles,_this.state.currentStyles,_this.state.currentVelocities,_this.state.lastIdealStyles,_this.state.lastIdealVelocities);var mergedPropsStyles=_mergeAndSync[0];var currentStyles=_mergeAndSync[1];var currentVelocities=_mergeAndSync[2];var lastIdealStyles=_mergeAndSync[3];var lastIdealVelocities=_mergeAndSync[4];for(var i=0;i<unreadPropStyles.length;i++){var unreadPropStyle=unreadPropStyles[i].style;var dirty=false;for(var key in unreadPropStyle){if(!Object.prototype.hasOwnProperty.call(unreadPropStyle,key)){continue;}var styleValue=unreadPropStyle[key];if(typeof styleValue==='number'){if(!dirty){dirty=true;currentStyles[i]=_extends({},currentStyles[i]);currentVelocities[i]=_extends({},currentVelocities[i]);lastIdealStyles[i]=_extends({},lastIdealStyles[i]);lastIdealVelocities[i]=_extends({},lastIdealVelocities[i]);mergedPropsStyles[i]={key:mergedPropsStyles[i].key,data:mergedPropsStyles[i].data,style:_extends({},mergedPropsStyles[i].style)};}currentStyles[i][key]=styleValue;currentVelocities[i][key]=0;lastIdealStyles[i][key]=styleValue;lastIdealVelocities[i][key]=0;mergedPropsStyles[i].style[key]=styleValue;}}}// unlike the other 2 components, we can't detect staleness and optionally
// opt out of setState here. each style object's data might contain new
// stuff we're not/cannot compare
_this.setState({currentStyles:currentStyles,currentVelocities:currentVelocities,mergedPropsStyles:mergedPropsStyles,lastIdealStyles:lastIdealStyles,lastIdealVelocities:lastIdealVelocities});};this.startAnimationIfNecessary=function(){if(_this.unmounting){return;}// TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
// call cb? No, otherwise accidental parent rerender causes cb trigger
_this.animationID=_raf2['default'](function(timestamp){// https://github.com/chenglou/react-motion/pull/420
// > if execution passes the conditional if (this.unmounting), then
// executes async defaultRaf and after that component unmounts and after
// that the callback of defaultRaf is called, then setState will be called
// on unmounted component.
if(_this.unmounting){return;}var propStyles=_this.props.styles;var destStyles=typeof propStyles==='function'?propStyles(rehydrateStyles(_this.state.mergedPropsStyles,_this.unreadPropStyles,_this.state.lastIdealStyles)):propStyles;// check if we need to animate in the first place
if(shouldStopAnimationAll(_this.state.currentStyles,destStyles,_this.state.currentVelocities,_this.state.mergedPropsStyles)){// no need to cancel animationID here; shouldn't have any in flight
_this.animationID=null;_this.accumulatedTime=0;return;}var currentTime=timestamp||_performanceNow2['default']();var timeDelta=currentTime-_this.prevTime;_this.prevTime=currentTime;_this.accumulatedTime=_this.accumulatedTime+timeDelta;// more than 10 frames? prolly switched browser tab. Restart
if(_this.accumulatedTime>msPerFrame*10){_this.accumulatedTime=0;}if(_this.accumulatedTime===0){// no need to cancel animationID here; shouldn't have any in flight
_this.animationID=null;_this.startAnimationIfNecessary();return;}var currentFrameCompletion=(_this.accumulatedTime-Math.floor(_this.accumulatedTime/msPerFrame)*msPerFrame)/msPerFrame;var framesToCatchUp=Math.floor(_this.accumulatedTime/msPerFrame);var _mergeAndSync2=mergeAndSync(_this.props.willEnter,_this.props.willLeave,_this.props.didLeave,_this.state.mergedPropsStyles,destStyles,_this.state.currentStyles,_this.state.currentVelocities,_this.state.lastIdealStyles,_this.state.lastIdealVelocities);var newMergedPropsStyles=_mergeAndSync2[0];var newCurrentStyles=_mergeAndSync2[1];var newCurrentVelocities=_mergeAndSync2[2];var newLastIdealStyles=_mergeAndSync2[3];var newLastIdealVelocities=_mergeAndSync2[4];for(var i=0;i<newMergedPropsStyles.length;i++){var newMergedPropsStyle=newMergedPropsStyles[i].style;var newCurrentStyle={};var newCurrentVelocity={};var newLastIdealStyle={};var newLastIdealVelocity={};for(var key in newMergedPropsStyle){if(!Object.prototype.hasOwnProperty.call(newMergedPropsStyle,key)){continue;}var styleValue=newMergedPropsStyle[key];if(typeof styleValue==='number'){newCurrentStyle[key]=styleValue;newCurrentVelocity[key]=0;newLastIdealStyle[key]=styleValue;newLastIdealVelocity[key]=0;}else{var newLastIdealStyleValue=newLastIdealStyles[i][key];var newLastIdealVelocityValue=newLastIdealVelocities[i][key];for(var j=0;j<framesToCatchUp;j++){var _stepper=_stepper4['default'](msPerFrame/1000,newLastIdealStyleValue,newLastIdealVelocityValue,styleValue.val,styleValue.stiffness,styleValue.damping,styleValue.precision);newLastIdealStyleValue=_stepper[0];newLastIdealVelocityValue=_stepper[1];}var _stepper2=_stepper4['default'](msPerFrame/1000,newLastIdealStyleValue,newLastIdealVelocityValue,styleValue.val,styleValue.stiffness,styleValue.damping,styleValue.precision);var nextIdealX=_stepper2[0];var nextIdealV=_stepper2[1];newCurrentStyle[key]=newLastIdealStyleValue+(nextIdealX-newLastIdealStyleValue)*currentFrameCompletion;newCurrentVelocity[key]=newLastIdealVelocityValue+(nextIdealV-newLastIdealVelocityValue)*currentFrameCompletion;newLastIdealStyle[key]=newLastIdealStyleValue;newLastIdealVelocity[key]=newLastIdealVelocityValue;}}newLastIdealStyles[i]=newLastIdealStyle;newLastIdealVelocities[i]=newLastIdealVelocity;newCurrentStyles[i]=newCurrentStyle;newCurrentVelocities[i]=newCurrentVelocity;}_this.animationID=null;// the amount we're looped over above
_this.accumulatedTime-=framesToCatchUp*msPerFrame;_this.setState({currentStyles:newCurrentStyles,currentVelocities:newCurrentVelocities,lastIdealStyles:newLastIdealStyles,lastIdealVelocities:newLastIdealVelocities,mergedPropsStyles:newMergedPropsStyles});_this.unreadPropStyles=null;_this.startAnimationIfNecessary();});};this.state=this.defaultState();}TransitionMotion.prototype.defaultState=function defaultState(){var _props=this.props;var defaultStyles=_props.defaultStyles;var styles=_props.styles;var willEnter=_props.willEnter;var willLeave=_props.willLeave;var didLeave=_props.didLeave;var destStyles=typeof styles==='function'?styles(defaultStyles):styles;// this is special. for the first time around, we don't have a comparison
// between last (no last) and current merged props. we'll compute last so:
// say default is {a, b} and styles (dest style) is {b, c}, we'll
// fabricate last as {a, b}
var oldMergedPropsStyles=undefined;if(defaultStyles==null){oldMergedPropsStyles=destStyles;}else{oldMergedPropsStyles=defaultStyles.map(function(defaultStyleCell){// TODO: key search code
for(var i=0;i<destStyles.length;i++){if(destStyles[i].key===defaultStyleCell.key){return destStyles[i];}}return defaultStyleCell;});}var oldCurrentStyles=defaultStyles==null?destStyles.map(function(s){return _stripStyle2['default'](s.style);}):defaultStyles.map(function(s){return _stripStyle2['default'](s.style);});var oldCurrentVelocities=defaultStyles==null?destStyles.map(function(s){return _mapToZero2['default'](s.style);}):defaultStyles.map(function(s){return _mapToZero2['default'](s.style);});var _mergeAndSync3=mergeAndSync(// Because this is an old-style createReactClass component, Flow doesn't
// understand that the willEnter and willLeave props have default values
// and will always be present.
willEnter,willLeave,didLeave,oldMergedPropsStyles,destStyles,oldCurrentStyles,oldCurrentVelocities,oldCurrentStyles,// oldLastIdealStyles really
oldCurrentVelocities);var mergedPropsStyles=_mergeAndSync3[0];var currentStyles=_mergeAndSync3[1];var currentVelocities=_mergeAndSync3[2];var lastIdealStyles=_mergeAndSync3[3];var lastIdealVelocities=_mergeAndSync3[4];// oldLastIdealVelocities really
return{currentStyles:currentStyles,currentVelocities:currentVelocities,lastIdealStyles:lastIdealStyles,lastIdealVelocities:lastIdealVelocities,mergedPropsStyles:mergedPropsStyles};};// after checking for unreadPropStyles != null, we manually go set the
// non-interpolating values (those that are a number, without a spring
// config)
TransitionMotion.prototype.componentDidMount=function componentDidMount(){this.prevTime=_performanceNow2['default']();this.startAnimationIfNecessary();};TransitionMotion.prototype.componentWillReceiveProps=function componentWillReceiveProps(props){if(this.unreadPropStyles){// previous props haven't had the chance to be set yet; set them here
this.clearUnreadPropStyle(this.unreadPropStyles);}var styles=props.styles;if(typeof styles==='function'){this.unreadPropStyles=styles(rehydrateStyles(this.state.mergedPropsStyles,this.unreadPropStyles,this.state.lastIdealStyles));}else{this.unreadPropStyles=styles;}if(this.animationID==null){this.prevTime=_performanceNow2['default']();this.startAnimationIfNecessary();}};TransitionMotion.prototype.componentWillUnmount=function componentWillUnmount(){this.unmounting=true;if(this.animationID!=null){_raf2['default'].cancel(this.animationID);this.animationID=null;}};TransitionMotion.prototype.render=function render(){var hydratedStyles=rehydrateStyles(this.state.mergedPropsStyles,this.unreadPropStyles,this.state.currentStyles);var renderedChildren=this.props.children(hydratedStyles);return renderedChildren&&_react2['default'].Children.only(renderedChildren);};return TransitionMotion;}(_react2['default'].Component);exports["default"]=TransitionMotion;module.exports=exports['default'];// list of styles, each containing interpolating values. Part of what's passed
// to children function. Notice that this is
// Array<ActualInterpolatingStyleObject>, without the wrapper that is {key: ...,
// data: ... style: ActualInterpolatingStyleObject}. Only mergedPropsStyles
// contains the key & data info (so that we only have a single source of truth
// for these, and to save space). Check the comment for `rehydrateStyles` to
// see how we regenerate the entirety of what's passed to children function
// the array that keeps track of currently rendered stuff! Including stuff
// that you've unmounted but that's still animating. This is where it lives
// it's possible that currentStyle's value is stale: if props is immediately
// changed from 0 to 400 to spring(0) again, the async currentStyle is still
// at 0 (didn't have time to tick and interpolate even once). If we naively
// compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
// In reality currentStyle should be 400

/***/ }),

/***/ 34419:
/***/ ((module, exports) => {

"use strict";
// currently used to initiate the velocity style object to 0
exports.__esModule=true;exports["default"]=mapToZero;function mapToZero(obj){var ret={};for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){ret[key]=0;}}return ret;}module.exports=exports['default'];

/***/ }),

/***/ 8940:
/***/ ((module, exports) => {

"use strict";
// core keys merging algorithm. If previous render's keys are [a, b], and the
// next render's [c, b, d], what's the final merged keys and ordering?
// - c and a must both be before b
// - b before d
// - ordering between a and c ambiguous
// this reduces to merging two partially ordered lists (e.g. lists where not
// every item has a definite ordering, like comparing a and c above). For the
// ambiguous ordering we deterministically choose to place the next render's
// item after the previous'; so c after a
// this is called a topological sorting. Except the existing algorithms don't
// work well with js bc of the amount of allocation, and isn't optimized for our
// current use-case bc the runtime is linear in terms of edges (see wiki for
// meaning), which is huge when two lists have many common elements
exports.__esModule=true;exports["default"]=mergeDiff;function mergeDiff(prev,next,onRemove){// bookkeeping for easier access of a key's index below. This is 2 allocations +
// potentially triggering chrome hash map mode for objs (so it might be faster
var prevKeyIndex={};for(var i=0;i<prev.length;i++){prevKeyIndex[prev[i].key]=i;}var nextKeyIndex={};for(var i=0;i<next.length;i++){nextKeyIndex[next[i].key]=i;}// first, an overly elaborate way of merging prev and next, eliminating
// duplicates (in terms of keys). If there's dupe, keep the item in next).
// This way of writing it saves allocations
var ret=[];for(var i=0;i<next.length;i++){ret[i]=next[i];}for(var i=0;i<prev.length;i++){if(!Object.prototype.hasOwnProperty.call(nextKeyIndex,prev[i].key)){// this is called my TM's `mergeAndSync`, which calls willLeave. We don't
// merge in keys that the user desires to kill
var fill=onRemove(i,prev[i]);if(fill!=null){ret.push(fill);}}}// now all the items all present. Core sorting logic to have the right order
return ret.sort(function(a,b){var nextOrderA=nextKeyIndex[a.key];var nextOrderB=nextKeyIndex[b.key];var prevOrderA=prevKeyIndex[a.key];var prevOrderB=prevKeyIndex[b.key];if(nextOrderA!=null&&nextOrderB!=null){// both keys in next
return nextKeyIndex[a.key]-nextKeyIndex[b.key];}else if(prevOrderA!=null&&prevOrderB!=null){// both keys in prev
return prevKeyIndex[a.key]-prevKeyIndex[b.key];}else if(nextOrderA!=null){// key a in next, key b in prev
// how to determine the order between a and b? We find a "pivot" (term
// abuse), a key present in both prev and next, that is sandwiched between
// a and b. In the context of our above example, if we're comparing a and
// d, b's (the only) pivot
for(var i=0;i<next.length;i++){var pivot=next[i].key;if(!Object.prototype.hasOwnProperty.call(prevKeyIndex,pivot)){continue;}if(nextOrderA<nextKeyIndex[pivot]&&prevOrderB>prevKeyIndex[pivot]){return-1;}else if(nextOrderA>nextKeyIndex[pivot]&&prevOrderB<prevKeyIndex[pivot]){return 1;}}// pluggable. default to: next bigger than prev
return 1;}// prevOrderA, nextOrderB
for(var i=0;i<next.length;i++){var pivot=next[i].key;if(!Object.prototype.hasOwnProperty.call(prevKeyIndex,pivot)){continue;}if(nextOrderB<nextKeyIndex[pivot]&&prevOrderA>prevKeyIndex[pivot]){return 1;}else if(nextOrderB>nextKeyIndex[pivot]&&prevOrderA<prevKeyIndex[pivot]){return-1;}}// pluggable. default to: next bigger than prev
return-1;});}module.exports=exports['default'];// to loop through and find a key's index each time), but I no longer care

/***/ }),

/***/ 43485:
/***/ ((module, exports) => {

"use strict";
exports.__esModule=true;exports["default"]={noWobble:{stiffness:170,damping:26},// the default, if nothing provided
gentle:{stiffness:120,damping:14},wobbly:{stiffness:180,damping:12},stiff:{stiffness:210,damping:20}};module.exports=exports["default"];

/***/ }),

/***/ 82420:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
__webpack_unused_export__=true;function _interopRequire(obj){return obj&&obj.__esModule?obj['default']:obj;}var _Motion=__webpack_require__(19143);exports.y_=_interopRequire(_Motion);var _StaggeredMotion=__webpack_require__(40164);__webpack_unused_export__=_interopRequire(_StaggeredMotion);var _TransitionMotion=__webpack_require__(96081);__webpack_unused_export__=_interopRequire(_TransitionMotion);var _spring=__webpack_require__(62849);exports.ST=_interopRequire(_spring);var _presets=__webpack_require__(43485);__webpack_unused_export__=_interopRequire(_presets);var _stripStyle=__webpack_require__(93374);__webpack_unused_export__=_interopRequire(_stripStyle);// deprecated, dummy warning function
var _reorderKeys=__webpack_require__(57120);__webpack_unused_export__=_interopRequire(_reorderKeys);

/***/ }),

/***/ 57120:
/***/ ((module, exports) => {

"use strict";
exports.__esModule=true;exports["default"]=reorderKeys;var hasWarned=false;function reorderKeys(){if(false){}}module.exports=exports['default'];

/***/ }),

/***/ 18412:
/***/ ((module, exports) => {

"use strict";
// usage assumption: currentStyle values have already been rendered but it says
// nothing of whether currentStyle is stale (see unreadPropStyle)
exports.__esModule=true;exports["default"]=shouldStopAnimation;function shouldStopAnimation(currentStyle,style,currentVelocity){for(var key in style){if(!Object.prototype.hasOwnProperty.call(style,key)){continue;}if(currentVelocity[key]!==0){return false;}var styleValue=typeof style[key]==='number'?style[key]:style[key].val;// stepper will have already taken care of rounding precision errors, so
// won't have such thing as 0.9999 !=== 1
if(currentStyle[key]!==styleValue){return false;}}return true;}module.exports=exports['default'];

/***/ }),

/***/ 62849:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
exports.__esModule=true;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};exports["default"]=spring;function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{'default':obj};}var _presets=__webpack_require__(43485);var _presets2=_interopRequireDefault(_presets);var defaultConfig=_extends({},_presets2['default'].noWobble,{precision:0.01});function spring(val,config){return _extends({},defaultConfig,config,{val:val});}module.exports=exports['default'];

/***/ }),

/***/ 98299:
/***/ ((module, exports) => {

"use strict";
// stepper is used a lot. Saves allocation to return the same array wrapper.
// This is fine and danger-free against mutations because the callsite
// immediately destructures it and gets the numbers inside without passing the
exports.__esModule=true;exports["default"]=stepper;var reusedTuple=[0,0];function stepper(secondPerFrame,x,v,destX,k,b,precision){// Spring stiffness, in kg / s^2
// for animations, destX is really spring length (spring at rest). initial
// position is considered as the stretched/compressed position of a spring
var Fspring=-k*(x-destX);// Damping, in kg / s
var Fdamper=-b*v;// usually we put mass here, but for animation purposes, specifying mass is a
// bit redundant. you could simply adjust k and b accordingly
// let a = (Fspring + Fdamper) / mass;
var a=Fspring+Fdamper;var newV=v+a*secondPerFrame;var newX=x+newV*secondPerFrame;if(Math.abs(newV)<precision&&Math.abs(newX-destX)<precision){reusedTuple[0]=destX;reusedTuple[1]=0;return reusedTuple;}reusedTuple[0]=newX;reusedTuple[1]=newV;return reusedTuple;}module.exports=exports["default"];// array reference around.

/***/ }),

/***/ 93374:
/***/ ((module, exports) => {

"use strict";
// turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by
// `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}
exports.__esModule=true;exports["default"]=stripStyle;function stripStyle(style){var ret={};for(var key in style){if(!Object.prototype.hasOwnProperty.call(style,key)){continue;}ret[key]=typeof style[key]==='number'?style[key]:style[key].val;}return ret;}module.exports=exports['default'];

/***/ })

}]);